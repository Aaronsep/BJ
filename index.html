<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Balanceador óptimo de trabajos</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; max-width: 1000px; }
    h1 { margin: 0 0 12px; font-size: 22px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 10px 0; }
    textarea { width: 100%; min-height: 220px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; padding: 10px; }
    input[type="number"] { width: 100px; padding: 6px; }
    button { padding: 10px 14px; cursor: pointer; }
    .note { font-size: 13px; color: #444; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .ok { color: #0a7; }
    .bad { color: #c33; }
    @media (max-width: 900px){ .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <h1>Balanceador óptimo de trabajos (K equipos)</h1>

  <div class="note">
    Formato: una línea por trabajo. Ejemplos:
    <span class="mono">A 1.37</span> (horas decimales),
    <span class="mono">B 2:25</span> (h:mm),
    <span class="mono">C 0:55</span>.
    Separadores: espacio o coma.
  </div>

  <div class="row">
    <label>Equipos (K): <input id="k" type="number" min="1" value="2"></label>
    <label>Precisión (minutos por unidad): <input id="quant" type="number" min="1" value="1"></label>
    <button id="solveBtn">Resolver óptimo</button>
    <button id="demoBtn" type="button">Cargar demo</button>
  </div>

  <textarea id="jobs" placeholder="A 1.37&#10;B 2.41&#10;C 0:55"></textarea>

  <div id="status" class="note"></div>

  <div class="grid">
    <div class="card">
      <div class="note"><b>Resultado</b></div>
      <pre id="out" class="mono" style="white-space: pre-wrap; margin: 8px 0 0;"></pre>
    </div>
    <div class="card">
      <div class="note"><b>Copiar como texto</b></div>
      <button id="copyBtn" type="button">Copiar resultado</button>
      <pre id="copyOut" class="mono" style="white-space: pre-wrap; margin: 8px 0 0;"></pre>
    </div>
  </div>

<script>
(function(){
  const elJobs = document.getElementById('jobs');
  const elK = document.getElementById('k');
  const elQuant = document.getElementById('quant');
  const elOut = document.getElementById('out');
  const elCopyOut = document.getElementById('copyOut');
  const elStatus = document.getElementById('status');

  document.getElementById('demoBtn').addEventListener('click', () => {
    elJobs.value =
`A 1.37
B 2.41
C 0:55
D 1.25
E 0.80
F 1:10
G 0:40
H 1.90`;
  });

  document.getElementById('copyBtn').addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(elCopyOut.textContent || '');
      elStatus.innerHTML = '<span class="ok">Copiado.</span>';
    } catch {
      elStatus.innerHTML = '<span class="bad">No se pudo copiar (permiso del navegador).</span>';
    }
  });

  function parseTimeToMinutes(s){
    s = String(s).trim();
    if (s.includes(':')) {
      const [h,m] = s.split(':');
      const hh = parseInt(h.trim(),10);
      const mm = parseInt(m.trim(),10);
      if (!Number.isFinite(hh) || !Number.isFinite(mm)) throw new Error('Tiempo inválido: ' + s);
      return hh*60 + mm;
    }
    // horas decimales
    s = s.replace(',', '.');
    const hours = parseFloat(s);
    if (!Number.isFinite(hours)) throw new Error('Tiempo inválido: ' + s);
    return Math.round(hours*60);
  }

  function parseJobs(text){
    const lines = text.split(/\r?\n/);
    const jobs = [];
    for (const ln of lines){
      const t = ln.trim();
      if (!t) continue;
      const parts = t.split(/[,\s]+/).filter(Boolean);
      if (parts.length < 2) throw new Error('Línea inválida: ' + ln);
      const name = parts[0];
      const minutes = parseTimeToMinutes(parts[1]);
      if (minutes <= 0) throw new Error('Tiempo <= 0: ' + ln);
      jobs.push({name, minutes});
    }
    return jobs;
  }

  function hhmm(min){
    const h = Math.floor(min/60);
    const m = min%60;
    return `${h}:${String(m).padStart(2,'0')}`;
  }

  // Branch & Bound óptimo: minimizar makespan para K máquinas idénticas
  // Con simetrías: cargas ordenadas, evita permutar equipos equivalentes.
  function solveOptimal(jobs, K, quant){
    // cuantización (por defecto 1 min); si pones 5, acelera pero ya no es exacto al minuto
    const q = Math.max(1, quant|0);

    const items = jobs
      .map(j => ({name: j.name, w: Math.max(1, Math.round(j.minutes / q))}))
      .sort((a,b)=>b.w-a.w);

    const n = items.length;
    const total = items.reduce((s,x)=>s+x.w,0);

    // bound inicial: greedy LPT para tener un upper bound bueno
    const loads0 = Array(K).fill(0);
    const assign0 = Array.from({length: K}, ()=>[]);
    for (const it of items){
      let best = 0;
      for (let i=1;i<K;i++) if (loads0[i] < loads0[best]) best = i;
      loads0[best] += it.w;
      assign0[best].push(it);
    }
    let bestMakespan = Math.max(...loads0);
    let bestAssign = assign0.map(a=>a.slice());

    // lower bound global (promedio)
    const avgLB = Math.ceil(total / K);

    // estado
    const loads = Array(K).fill(0);
    const assign = Array.from({length: K}, ()=>[]);

    // Para poda: suma restante
    const suffixSum = Array(n+1).fill(0);
    for (let i=n-1;i>=0;i--) suffixSum[i] = suffixSum[i+1] + items[i].w;

    // truco: memo simple por (idx, loads sorted) para podar estados repetidos
    const seen = new Set();
    function key(idx, loadsArr){
      const sorted = loadsArr.slice().sort((a,b)=>a-b).join(',');
      return idx + '|' + sorted;
    }

    function dfs(idx){
      if (idx === n){
        const mk = Math.max(...loads);
        if (mk < bestMakespan){
          bestMakespan = mk;
          bestAssign = assign.map(a=>a.slice());
        }
        return;
      }

      // bound: mejor posible no puede ser menor que avgLB ni menor que max(loads)
      const currentMax = Math.max(...loads);
      const lb = Math.max(avgLB, currentMax);
      if (lb >= bestMakespan) return;

      // otro bound: aunque repartas perfecto lo restante, el max no puede bajar de:
      // max(currentMax, ceil((sumRemaining + sumLoads)/K)) == ceil(total/K) ya considerado
      // Poda por estado repetido
      const k = key(idx, loads);
      if (seen.has(k)) return;
      seen.add(k);

      const it = items[idx];

      // simetría: si dos equipos tienen misma carga, probar solo uno para este item
      const tried = new Set();

      // ordena equipos por carga asc para intentar rellenar primero los menos cargados
      const order = Array.from({length: K}, (_,i)=>i).sort((a,b)=>loads[a]-loads[b]);

      for (const i of order){
        const L = loads[i];
        if (tried.has(L)) continue;
        tried.add(L);

        const newLoad = L + it.w;
        if (newLoad >= bestMakespan) continue;

        loads[i] = newLoad;
        assign[i].push(it);

        // bound extra: si el máximo ya se acerca al best y además queda poco por repartir, igual poda simple
        dfs(idx+1);

        assign[i].pop();
        loads[i] = L;

        // si este equipo estaba vacío y no funcionó, no pruebes otros vacíos (simetría fuerte)
        if (L === 0) break;
      }
    }

    dfs(0);

    // reconstruir a minutos reales
    const teams = bestAssign.map(team => {
      const jobsTeam = team.map(it => {
        const original = jobs.find(j=>j.name===it.name);
        return { name: it.name, minutes: original ? original.minutes : it.w*q };
      });
      jobsTeam.sort((a,b)=>b.minutes-a.minutes);
      const sumMin = jobsTeam.reduce((s,x)=>s+x.minutes,0);
      return { jobs: jobsTeam, totalMinutes: sumMin };
    });

    // makespan en minutos reales (recalcular con minutos originales)
    const makespanMinutes = Math.max(...teams.map(t=>t.totalMinutes));
    return { teams, makespanMinutes, quantMinutes: q };
  }

  document.getElementById('solveBtn').addEventListener('click', () => {
    try {
      elOut.textContent = '';
      elCopyOut.textContent = '';
      elStatus.textContent = 'Resolviendo (óptimo)...';

      const K = parseInt(elK.value, 10);
      const quant = parseInt(elQuant.value, 10);
      if (!Number.isFinite(K) || K < 1) throw new Error('K inválido');
      if (!Number.isFinite(quant) || quant < 1) throw new Error('Precisión inválida');

      const jobs = parseJobs(elJobs.value);
      if (jobs.length === 0) throw new Error('No hay trabajos');

      // Aviso honesto: óptimo puede explotar en n grande
      if (jobs.length > 80 && quant === 1){
        elStatus.innerHTML = '<span class="bad">Advertencia:</span> con muchos trabajos, resolver óptimo al minuto puede tardar bastante. Si tarda, sube "Precisión" a 2, 5 o 10 para acelerar (ya no sería exacto al minuto).';
      } else {
        elStatus.textContent = 'Resolviendo (óptimo)...';
      }

      // Ejecuta en el event loop para que se pinte status
      setTimeout(() => {
        const t0 = performance.now();
        const res = solveOptimal(jobs, K, quant);
        const t1 = performance.now();

        const totals = res.teams.map(t=>t.totalMinutes);
        const minT = Math.min(...totals);
        const maxT = Math.max(...totals);

        let out = '';
        out += `Equipos: ${K}\n`;
        out += `Trabajos: ${jobs.length}\n`;
        out += `Makespan óptimo: ${maxT} min (${hhmm(maxT)})\n`;
        out += `Min total: ${minT} min (${hhmm(minT)})\n`;
        out += `Diferencia: ${maxT - minT} min (${hhmm(maxT - minT)})\n`;
        out += `Tiempo de cómputo: ${Math.round(t1 - t0)} ms\n\n`;

        res.teams.forEach((team, idx) => {
          out += `Equipo ${idx+1} | Total: ${team.totalMinutes} min (${hhmm(team.totalMinutes)})\n`;
          team.jobs.forEach(j => {
            out += `  - ${j.name}: ${j.minutes} min (${hhmm(j.minutes)})\n`;
          });
          out += `\n`;
        });

        elOut.textContent = out;
        elCopyOut.textContent = out;
        elStatus.innerHTML = '<span class="ok">Listo.</span>';
      }, 10);

    } catch (e){
      elStatus.innerHTML = '<span class="bad">Error:</span> ' + (e && e.message ? e.message : String(e));
    }
  });

})();
</script>
</body>
</html>